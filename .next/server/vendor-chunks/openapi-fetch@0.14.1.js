"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/openapi-fetch@0.14.1";
exports.ids = ["vendor-chunks/openapi-fetch@0.14.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/openapi-fetch@0.14.1/node_modules/openapi-fetch/dist/index.mjs":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/openapi-fetch@0.14.1/node_modules/openapi-fetch/dist/index.mjs ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createFinalURL: () => (/* binding */ createFinalURL),\n/* harmony export */   createPathBasedClient: () => (/* binding */ createPathBasedClient),\n/* harmony export */   createQuerySerializer: () => (/* binding */ createQuerySerializer),\n/* harmony export */   \"default\": () => (/* binding */ createClient),\n/* harmony export */   defaultBodySerializer: () => (/* binding */ defaultBodySerializer),\n/* harmony export */   defaultPathSerializer: () => (/* binding */ defaultPathSerializer),\n/* harmony export */   mergeHeaders: () => (/* binding */ mergeHeaders),\n/* harmony export */   randomID: () => (/* binding */ randomID),\n/* harmony export */   removeTrailingSlash: () => (/* binding */ removeTrailingSlash),\n/* harmony export */   serializeArrayParam: () => (/* binding */ serializeArrayParam),\n/* harmony export */   serializeObjectParam: () => (/* binding */ serializeObjectParam),\n/* harmony export */   serializePrimitiveParam: () => (/* binding */ serializePrimitiveParam),\n/* harmony export */   wrapAsPathBasedClient: () => (/* binding */ wrapAsPathBasedClient)\n/* harmony export */ });\nconst PATH_PARAM_RE = /\\{[^{}]+\\}/g;\nconst supportsRequestInitExt = () => {\n  return typeof process === \"object\" && Number.parseInt(process?.versions?.node?.substring(0, 2)) >= 18 && process.versions.undici;\n};\nfunction randomID() {\n  return Math.random().toString(36).slice(2, 11);\n}\nfunction createClient(clientOptions) {\n  let {\n    baseUrl = \"\",\n    Request: CustomRequest = globalThis.Request,\n    fetch: baseFetch = globalThis.fetch,\n    querySerializer: globalQuerySerializer,\n    bodySerializer: globalBodySerializer,\n    headers: baseHeaders,\n    requestInitExt = void 0,\n    ...baseOptions\n  } = { ...clientOptions };\n  requestInitExt = supportsRequestInitExt() ? requestInitExt : void 0;\n  baseUrl = removeTrailingSlash(baseUrl);\n  const middlewares = [];\n  async function coreFetch(schemaPath, fetchOptions) {\n    const {\n      baseUrl: localBaseUrl,\n      fetch = baseFetch,\n      Request = CustomRequest,\n      headers,\n      params = {},\n      parseAs = \"json\",\n      querySerializer: requestQuerySerializer,\n      bodySerializer = globalBodySerializer ?? defaultBodySerializer,\n      body,\n      ...init\n    } = fetchOptions || {};\n    let finalBaseUrl = baseUrl;\n    if (localBaseUrl) {\n      finalBaseUrl = removeTrailingSlash(localBaseUrl) ?? baseUrl;\n    }\n    let querySerializer = typeof globalQuerySerializer === \"function\" ? globalQuerySerializer : createQuerySerializer(globalQuerySerializer);\n    if (requestQuerySerializer) {\n      querySerializer = typeof requestQuerySerializer === \"function\" ? requestQuerySerializer : createQuerySerializer({\n        ...typeof globalQuerySerializer === \"object\" ? globalQuerySerializer : {},\n        ...requestQuerySerializer\n      });\n    }\n    const serializedBody = body === void 0 ? void 0 : bodySerializer(\n      body,\n      // Note: we declare mergeHeaders() both here and below because it’s a bit of a chicken-or-egg situation:\n      // bodySerializer() needs all headers so we aren’t dropping ones set by the user, however,\n      // the result of this ALSO sets the lowest-priority content-type header. So we re-merge below,\n      // setting the content-type at the very beginning to be overwritten.\n      // Lastly, based on the way headers work, it’s not a simple “present-or-not” check becauase null intentionally un-sets headers.\n      mergeHeaders(baseHeaders, headers, params.header)\n    );\n    const finalHeaders = mergeHeaders(\n      // with no body, we should not to set Content-Type\n      serializedBody === void 0 || // if serialized body is FormData; browser will correctly set Content-Type & boundary expression\n      serializedBody instanceof FormData ? {} : {\n        \"Content-Type\": \"application/json\"\n      },\n      baseHeaders,\n      headers,\n      params.header\n    );\n    const requestInit = {\n      redirect: \"follow\",\n      ...baseOptions,\n      ...init,\n      body: serializedBody,\n      headers: finalHeaders\n    };\n    let id;\n    let options;\n    let request = new Request(\n      createFinalURL(schemaPath, { baseUrl: finalBaseUrl, params, querySerializer }),\n      requestInit\n    );\n    let response;\n    for (const key in init) {\n      if (!(key in request)) {\n        request[key] = init[key];\n      }\n    }\n    if (middlewares.length) {\n      id = randomID();\n      options = Object.freeze({\n        baseUrl: finalBaseUrl,\n        fetch,\n        parseAs,\n        querySerializer,\n        bodySerializer\n      });\n      for (const m of middlewares) {\n        if (m && typeof m === \"object\" && typeof m.onRequest === \"function\") {\n          const result = await m.onRequest({\n            request,\n            schemaPath,\n            params,\n            options,\n            id\n          });\n          if (result) {\n            if (result instanceof Request) {\n              request = result;\n            } else if (result instanceof Response) {\n              response = result;\n              break;\n            } else {\n              throw new Error(\"onRequest: must return new Request() or Response() when modifying the request\");\n            }\n          }\n        }\n      }\n    }\n    if (!response) {\n      try {\n        response = await fetch(request, requestInitExt);\n      } catch (error2) {\n        let errorAfterMiddleware = error2;\n        if (middlewares.length) {\n          for (let i = middlewares.length - 1; i >= 0; i--) {\n            const m = middlewares[i];\n            if (m && typeof m === \"object\" && typeof m.onError === \"function\") {\n              const result = await m.onError({\n                request,\n                error: errorAfterMiddleware,\n                schemaPath,\n                params,\n                options,\n                id\n              });\n              if (result) {\n                if (result instanceof Response) {\n                  errorAfterMiddleware = void 0;\n                  response = result;\n                  break;\n                }\n                if (result instanceof Error) {\n                  errorAfterMiddleware = result;\n                  continue;\n                }\n                throw new Error(\"onError: must return new Response() or instance of Error\");\n              }\n            }\n          }\n        }\n        if (errorAfterMiddleware) {\n          throw errorAfterMiddleware;\n        }\n      }\n      if (middlewares.length) {\n        for (let i = middlewares.length - 1; i >= 0; i--) {\n          const m = middlewares[i];\n          if (m && typeof m === \"object\" && typeof m.onResponse === \"function\") {\n            const result = await m.onResponse({\n              request,\n              response,\n              schemaPath,\n              params,\n              options,\n              id\n            });\n            if (result) {\n              if (!(result instanceof Response)) {\n                throw new Error(\"onResponse: must return new Response() when modifying the response\");\n              }\n              response = result;\n            }\n          }\n        }\n      }\n    }\n    if (response.status === 204 || request.method === \"HEAD\" || response.headers.get(\"Content-Length\") === \"0\") {\n      return response.ok ? { data: void 0, response } : { error: void 0, response };\n    }\n    if (response.ok) {\n      if (parseAs === \"stream\") {\n        return { data: response.body, response };\n      }\n      return { data: await response[parseAs](), response };\n    }\n    let error = await response.text();\n    try {\n      error = JSON.parse(error);\n    } catch {\n    }\n    return { error, response };\n  }\n  return {\n    request(method, url, init) {\n      return coreFetch(url, { ...init, method: method.toUpperCase() });\n    },\n    /** Call a GET endpoint */\n    GET(url, init) {\n      return coreFetch(url, { ...init, method: \"GET\" });\n    },\n    /** Call a PUT endpoint */\n    PUT(url, init) {\n      return coreFetch(url, { ...init, method: \"PUT\" });\n    },\n    /** Call a POST endpoint */\n    POST(url, init) {\n      return coreFetch(url, { ...init, method: \"POST\" });\n    },\n    /** Call a DELETE endpoint */\n    DELETE(url, init) {\n      return coreFetch(url, { ...init, method: \"DELETE\" });\n    },\n    /** Call a OPTIONS endpoint */\n    OPTIONS(url, init) {\n      return coreFetch(url, { ...init, method: \"OPTIONS\" });\n    },\n    /** Call a HEAD endpoint */\n    HEAD(url, init) {\n      return coreFetch(url, { ...init, method: \"HEAD\" });\n    },\n    /** Call a PATCH endpoint */\n    PATCH(url, init) {\n      return coreFetch(url, { ...init, method: \"PATCH\" });\n    },\n    /** Call a TRACE endpoint */\n    TRACE(url, init) {\n      return coreFetch(url, { ...init, method: \"TRACE\" });\n    },\n    /** Register middleware */\n    use(...middleware) {\n      for (const m of middleware) {\n        if (!m) {\n          continue;\n        }\n        if (typeof m !== \"object\" || !(\"onRequest\" in m || \"onResponse\" in m || \"onError\" in m)) {\n          throw new Error(\"Middleware must be an object with one of `onRequest()`, `onResponse() or `onError()`\");\n        }\n        middlewares.push(m);\n      }\n    },\n    /** Unregister middleware */\n    eject(...middleware) {\n      for (const m of middleware) {\n        const i = middlewares.indexOf(m);\n        if (i !== -1) {\n          middlewares.splice(i, 1);\n        }\n      }\n    }\n  };\n}\nclass PathCallForwarder {\n  constructor(client, url) {\n    this.client = client;\n    this.url = url;\n  }\n  GET = (init) => {\n    return this.client.GET(this.url, init);\n  };\n  PUT = (init) => {\n    return this.client.PUT(this.url, init);\n  };\n  POST = (init) => {\n    return this.client.POST(this.url, init);\n  };\n  DELETE = (init) => {\n    return this.client.DELETE(this.url, init);\n  };\n  OPTIONS = (init) => {\n    return this.client.OPTIONS(this.url, init);\n  };\n  HEAD = (init) => {\n    return this.client.HEAD(this.url, init);\n  };\n  PATCH = (init) => {\n    return this.client.PATCH(this.url, init);\n  };\n  TRACE = (init) => {\n    return this.client.TRACE(this.url, init);\n  };\n}\nclass PathClientProxyHandler {\n  constructor() {\n    this.client = null;\n  }\n  // Assume the property is an URL.\n  get(coreClient, url) {\n    const forwarder = new PathCallForwarder(coreClient, url);\n    this.client[url] = forwarder;\n    return forwarder;\n  }\n}\nfunction wrapAsPathBasedClient(coreClient) {\n  const handler = new PathClientProxyHandler();\n  const proxy = new Proxy(coreClient, handler);\n  function Client() {\n  }\n  Client.prototype = proxy;\n  const client = new Client();\n  handler.client = client;\n  return client;\n}\nfunction createPathBasedClient(clientOptions) {\n  return wrapAsPathBasedClient(createClient(clientOptions));\n}\nfunction serializePrimitiveParam(name, value, options) {\n  if (value === void 0 || value === null) {\n    return \"\";\n  }\n  if (typeof value === \"object\") {\n    throw new Error(\n      \"Deeply-nested arrays/objects aren\\u2019t supported. Provide your own `querySerializer()` to handle these.\"\n    );\n  }\n  return `${name}=${options?.allowReserved === true ? value : encodeURIComponent(value)}`;\n}\nfunction serializeObjectParam(name, value, options) {\n  if (!value || typeof value !== \"object\") {\n    return \"\";\n  }\n  const values = [];\n  const joiner = {\n    simple: \",\",\n    label: \".\",\n    matrix: \";\"\n  }[options.style] || \"&\";\n  if (options.style !== \"deepObject\" && options.explode === false) {\n    for (const k in value) {\n      values.push(k, options.allowReserved === true ? value[k] : encodeURIComponent(value[k]));\n    }\n    const final2 = values.join(\",\");\n    switch (options.style) {\n      case \"form\": {\n        return `${name}=${final2}`;\n      }\n      case \"label\": {\n        return `.${final2}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final2}`;\n      }\n      default: {\n        return final2;\n      }\n    }\n  }\n  for (const k in value) {\n    const finalName = options.style === \"deepObject\" ? `${name}[${k}]` : k;\n    values.push(serializePrimitiveParam(finalName, value[k], options));\n  }\n  const final = values.join(joiner);\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${final}` : final;\n}\nfunction serializeArrayParam(name, value, options) {\n  if (!Array.isArray(value)) {\n    return \"\";\n  }\n  if (options.explode === false) {\n    const joiner2 = { form: \",\", spaceDelimited: \"%20\", pipeDelimited: \"|\" }[options.style] || \",\";\n    const final = (options.allowReserved === true ? value : value.map((v) => encodeURIComponent(v))).join(joiner2);\n    switch (options.style) {\n      case \"simple\": {\n        return final;\n      }\n      case \"label\": {\n        return `.${final}`;\n      }\n      case \"matrix\": {\n        return `;${name}=${final}`;\n      }\n      // case \"spaceDelimited\":\n      // case \"pipeDelimited\":\n      default: {\n        return `${name}=${final}`;\n      }\n    }\n  }\n  const joiner = { simple: \",\", label: \".\", matrix: \";\" }[options.style] || \"&\";\n  const values = [];\n  for (const v of value) {\n    if (options.style === \"simple\" || options.style === \"label\") {\n      values.push(options.allowReserved === true ? v : encodeURIComponent(v));\n    } else {\n      values.push(serializePrimitiveParam(name, v, options));\n    }\n  }\n  return options.style === \"label\" || options.style === \"matrix\" ? `${joiner}${values.join(joiner)}` : values.join(joiner);\n}\nfunction createQuerySerializer(options) {\n  return function querySerializer(queryParams) {\n    const search = [];\n    if (queryParams && typeof queryParams === \"object\") {\n      for (const name in queryParams) {\n        const value = queryParams[name];\n        if (value === void 0 || value === null) {\n          continue;\n        }\n        if (Array.isArray(value)) {\n          if (value.length === 0) {\n            continue;\n          }\n          search.push(\n            serializeArrayParam(name, value, {\n              style: \"form\",\n              explode: true,\n              ...options?.array,\n              allowReserved: options?.allowReserved || false\n            })\n          );\n          continue;\n        }\n        if (typeof value === \"object\") {\n          search.push(\n            serializeObjectParam(name, value, {\n              style: \"deepObject\",\n              explode: true,\n              ...options?.object,\n              allowReserved: options?.allowReserved || false\n            })\n          );\n          continue;\n        }\n        search.push(serializePrimitiveParam(name, value, options));\n      }\n    }\n    return search.join(\"&\");\n  };\n}\nfunction defaultPathSerializer(pathname, pathParams) {\n  let nextURL = pathname;\n  for (const match of pathname.match(PATH_PARAM_RE) ?? []) {\n    let name = match.substring(1, match.length - 1);\n    let explode = false;\n    let style = \"simple\";\n    if (name.endsWith(\"*\")) {\n      explode = true;\n      name = name.substring(0, name.length - 1);\n    }\n    if (name.startsWith(\".\")) {\n      style = \"label\";\n      name = name.substring(1);\n    } else if (name.startsWith(\";\")) {\n      style = \"matrix\";\n      name = name.substring(1);\n    }\n    if (!pathParams || pathParams[name] === void 0 || pathParams[name] === null) {\n      continue;\n    }\n    const value = pathParams[name];\n    if (Array.isArray(value)) {\n      nextURL = nextURL.replace(match, serializeArrayParam(name, value, { style, explode }));\n      continue;\n    }\n    if (typeof value === \"object\") {\n      nextURL = nextURL.replace(match, serializeObjectParam(name, value, { style, explode }));\n      continue;\n    }\n    if (style === \"matrix\") {\n      nextURL = nextURL.replace(match, `;${serializePrimitiveParam(name, value)}`);\n      continue;\n    }\n    nextURL = nextURL.replace(match, style === \"label\" ? `.${encodeURIComponent(value)}` : encodeURIComponent(value));\n  }\n  return nextURL;\n}\nfunction defaultBodySerializer(body, headers) {\n  if (body instanceof FormData) {\n    return body;\n  }\n  if (headers) {\n    const contentType = headers.get instanceof Function ? headers.get(\"Content-Type\") ?? headers.get(\"content-type\") : headers[\"Content-Type\"] ?? headers[\"content-type\"];\n    if (contentType === \"application/x-www-form-urlencoded\") {\n      return new URLSearchParams(body).toString();\n    }\n  }\n  return JSON.stringify(body);\n}\nfunction createFinalURL(pathname, options) {\n  let finalURL = `${options.baseUrl}${pathname}`;\n  if (options.params?.path) {\n    finalURL = defaultPathSerializer(finalURL, options.params.path);\n  }\n  let search = options.querySerializer(options.params.query ?? {});\n  if (search.startsWith(\"?\")) {\n    search = search.substring(1);\n  }\n  if (search) {\n    finalURL += `?${search}`;\n  }\n  return finalURL;\n}\nfunction mergeHeaders(...allHeaders) {\n  const finalHeaders = new Headers();\n  for (const h of allHeaders) {\n    if (!h || typeof h !== \"object\") {\n      continue;\n    }\n    const iterator = h instanceof Headers ? h.entries() : Object.entries(h);\n    for (const [k, v] of iterator) {\n      if (v === null) {\n        finalHeaders.delete(k);\n      } else if (Array.isArray(v)) {\n        for (const v2 of v) {\n          finalHeaders.append(k, v2);\n        }\n      } else if (v !== void 0) {\n        finalHeaders.set(k, v);\n      }\n    }\n  }\n  return finalHeaders;\n}\nfunction removeTrailingSlash(url) {\n  if (url.endsWith(\"/\")) {\n    return url.substring(0, url.length - 1);\n  }\n  return url;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vb3BlbmFwaS1mZXRjaEAwLjE0LjEvbm9kZV9tb2R1bGVzL29wZW5hcGktZmV0Y2gvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLHlCQUF5QixJQUFJLElBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEUsOENBQThDO0FBQzlDO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0RBQWdEO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFvQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSwyQkFBMkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxnQkFBZ0I7QUFDMUY7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGdCQUFnQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsRUFBRSxxQ0FBcUM7QUFDaEY7QUFDQTtBQUNBLDZEQUE2RCwwQkFBMEI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCLEVBQUUsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1UjtBQUN2UiIsInNvdXJjZXMiOlsiRjpcXGNvZGVcXHJvZF96ZW1cXG5vZGVfbW9kdWxlc1xcLnBucG1cXG9wZW5hcGktZmV0Y2hAMC4xNC4xXFxub2RlX21vZHVsZXNcXG9wZW5hcGktZmV0Y2hcXGRpc3RcXGluZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBQQVRIX1BBUkFNX1JFID0gL1xce1tee31dK1xcfS9nO1xuY29uc3Qgc3VwcG9ydHNSZXF1ZXN0SW5pdEV4dCA9ICgpID0+IHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIE51bWJlci5wYXJzZUludChwcm9jZXNzPy52ZXJzaW9ucz8ubm9kZT8uc3Vic3RyaW5nKDAsIDIpKSA+PSAxOCAmJiBwcm9jZXNzLnZlcnNpb25zLnVuZGljaTtcbn07XG5mdW5jdGlvbiByYW5kb21JRCgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDExKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNsaWVudChjbGllbnRPcHRpb25zKSB7XG4gIGxldCB7XG4gICAgYmFzZVVybCA9IFwiXCIsXG4gICAgUmVxdWVzdDogQ3VzdG9tUmVxdWVzdCA9IGdsb2JhbFRoaXMuUmVxdWVzdCxcbiAgICBmZXRjaDogYmFzZUZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaCxcbiAgICBxdWVyeVNlcmlhbGl6ZXI6IGdsb2JhbFF1ZXJ5U2VyaWFsaXplcixcbiAgICBib2R5U2VyaWFsaXplcjogZ2xvYmFsQm9keVNlcmlhbGl6ZXIsXG4gICAgaGVhZGVyczogYmFzZUhlYWRlcnMsXG4gICAgcmVxdWVzdEluaXRFeHQgPSB2b2lkIDAsXG4gICAgLi4uYmFzZU9wdGlvbnNcbiAgfSA9IHsgLi4uY2xpZW50T3B0aW9ucyB9O1xuICByZXF1ZXN0SW5pdEV4dCA9IHN1cHBvcnRzUmVxdWVzdEluaXRFeHQoKSA/IHJlcXVlc3RJbml0RXh0IDogdm9pZCAwO1xuICBiYXNlVXJsID0gcmVtb3ZlVHJhaWxpbmdTbGFzaChiYXNlVXJsKTtcbiAgY29uc3QgbWlkZGxld2FyZXMgPSBbXTtcbiAgYXN5bmMgZnVuY3Rpb24gY29yZUZldGNoKHNjaGVtYVBhdGgsIGZldGNoT3B0aW9ucykge1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2VVcmw6IGxvY2FsQmFzZVVybCxcbiAgICAgIGZldGNoID0gYmFzZUZldGNoLFxuICAgICAgUmVxdWVzdCA9IEN1c3RvbVJlcXVlc3QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zID0ge30sXG4gICAgICBwYXJzZUFzID0gXCJqc29uXCIsXG4gICAgICBxdWVyeVNlcmlhbGl6ZXI6IHJlcXVlc3RRdWVyeVNlcmlhbGl6ZXIsXG4gICAgICBib2R5U2VyaWFsaXplciA9IGdsb2JhbEJvZHlTZXJpYWxpemVyID8/IGRlZmF1bHRCb2R5U2VyaWFsaXplcixcbiAgICAgIGJvZHksXG4gICAgICAuLi5pbml0XG4gICAgfSA9IGZldGNoT3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgZmluYWxCYXNlVXJsID0gYmFzZVVybDtcbiAgICBpZiAobG9jYWxCYXNlVXJsKSB7XG4gICAgICBmaW5hbEJhc2VVcmwgPSByZW1vdmVUcmFpbGluZ1NsYXNoKGxvY2FsQmFzZVVybCkgPz8gYmFzZVVybDtcbiAgICB9XG4gICAgbGV0IHF1ZXJ5U2VyaWFsaXplciA9IHR5cGVvZiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgPT09IFwiZnVuY3Rpb25cIiA/IGdsb2JhbFF1ZXJ5U2VyaWFsaXplciA6IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcihnbG9iYWxRdWVyeVNlcmlhbGl6ZXIpO1xuICAgIGlmIChyZXF1ZXN0UXVlcnlTZXJpYWxpemVyKSB7XG4gICAgICBxdWVyeVNlcmlhbGl6ZXIgPSB0eXBlb2YgcmVxdWVzdFF1ZXJ5U2VyaWFsaXplciA9PT0gXCJmdW5jdGlvblwiID8gcmVxdWVzdFF1ZXJ5U2VyaWFsaXplciA6IGNyZWF0ZVF1ZXJ5U2VyaWFsaXplcih7XG4gICAgICAgIC4uLnR5cGVvZiBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgPT09IFwib2JqZWN0XCIgPyBnbG9iYWxRdWVyeVNlcmlhbGl6ZXIgOiB7fSxcbiAgICAgICAgLi4ucmVxdWVzdFF1ZXJ5U2VyaWFsaXplclxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHNlcmlhbGl6ZWRCb2R5ID0gYm9keSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYm9keVNlcmlhbGl6ZXIoXG4gICAgICBib2R5LFxuICAgICAgLy8gTm90ZTogd2UgZGVjbGFyZSBtZXJnZUhlYWRlcnMoKSBib3RoIGhlcmUgYW5kIGJlbG93IGJlY2F1c2UgaXTigJlzIGEgYml0IG9mIGEgY2hpY2tlbi1vci1lZ2cgc2l0dWF0aW9uOlxuICAgICAgLy8gYm9keVNlcmlhbGl6ZXIoKSBuZWVkcyBhbGwgaGVhZGVycyBzbyB3ZSBhcmVu4oCZdCBkcm9wcGluZyBvbmVzIHNldCBieSB0aGUgdXNlciwgaG93ZXZlcixcbiAgICAgIC8vIHRoZSByZXN1bHQgb2YgdGhpcyBBTFNPIHNldHMgdGhlIGxvd2VzdC1wcmlvcml0eSBjb250ZW50LXR5cGUgaGVhZGVyLiBTbyB3ZSByZS1tZXJnZSBiZWxvdyxcbiAgICAgIC8vIHNldHRpbmcgdGhlIGNvbnRlbnQtdHlwZSBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgdG8gYmUgb3ZlcndyaXR0ZW4uXG4gICAgICAvLyBMYXN0bHksIGJhc2VkIG9uIHRoZSB3YXkgaGVhZGVycyB3b3JrLCBpdOKAmXMgbm90IGEgc2ltcGxlwqDigJxwcmVzZW50LW9yLW5vdOKAnSBjaGVjayBiZWNhdWFzZSBudWxsIGludGVudGlvbmFsbHkgdW4tc2V0cyBoZWFkZXJzLlxuICAgICAgbWVyZ2VIZWFkZXJzKGJhc2VIZWFkZXJzLCBoZWFkZXJzLCBwYXJhbXMuaGVhZGVyKVxuICAgICk7XG4gICAgY29uc3QgZmluYWxIZWFkZXJzID0gbWVyZ2VIZWFkZXJzKFxuICAgICAgLy8gd2l0aCBubyBib2R5LCB3ZSBzaG91bGQgbm90IHRvIHNldCBDb250ZW50LVR5cGVcbiAgICAgIHNlcmlhbGl6ZWRCb2R5ID09PSB2b2lkIDAgfHwgLy8gaWYgc2VyaWFsaXplZCBib2R5IGlzIEZvcm1EYXRhOyBicm93c2VyIHdpbGwgY29ycmVjdGx5IHNldCBDb250ZW50LVR5cGUgJiBib3VuZGFyeSBleHByZXNzaW9uXG4gICAgICBzZXJpYWxpemVkQm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhID8ge30gOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG4gICAgICB9LFxuICAgICAgYmFzZUhlYWRlcnMsXG4gICAgICBoZWFkZXJzLFxuICAgICAgcGFyYW1zLmhlYWRlclxuICAgICk7XG4gICAgY29uc3QgcmVxdWVzdEluaXQgPSB7XG4gICAgICByZWRpcmVjdDogXCJmb2xsb3dcIixcbiAgICAgIC4uLmJhc2VPcHRpb25zLFxuICAgICAgLi4uaW5pdCxcbiAgICAgIGJvZHk6IHNlcmlhbGl6ZWRCb2R5LFxuICAgICAgaGVhZGVyczogZmluYWxIZWFkZXJzXG4gICAgfTtcbiAgICBsZXQgaWQ7XG4gICAgbGV0IG9wdGlvbnM7XG4gICAgbGV0IHJlcXVlc3QgPSBuZXcgUmVxdWVzdChcbiAgICAgIGNyZWF0ZUZpbmFsVVJMKHNjaGVtYVBhdGgsIHsgYmFzZVVybDogZmluYWxCYXNlVXJsLCBwYXJhbXMsIHF1ZXJ5U2VyaWFsaXplciB9KSxcbiAgICAgIHJlcXVlc3RJbml0XG4gICAgKTtcbiAgICBsZXQgcmVzcG9uc2U7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5pdCkge1xuICAgICAgaWYgKCEoa2V5IGluIHJlcXVlc3QpKSB7XG4gICAgICAgIHJlcXVlc3Rba2V5XSA9IGluaXRba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pZGRsZXdhcmVzLmxlbmd0aCkge1xuICAgICAgaWQgPSByYW5kb21JRCgpO1xuICAgICAgb3B0aW9ucyA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBiYXNlVXJsOiBmaW5hbEJhc2VVcmwsXG4gICAgICAgIGZldGNoLFxuICAgICAgICBwYXJzZUFzLFxuICAgICAgICBxdWVyeVNlcmlhbGl6ZXIsXG4gICAgICAgIGJvZHlTZXJpYWxpemVyXG4gICAgICB9KTtcbiAgICAgIGZvciAoY29uc3QgbSBvZiBtaWRkbGV3YXJlcykge1xuICAgICAgICBpZiAobSAmJiB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbS5vblJlcXVlc3QgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25SZXF1ZXN0KHtcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIGlkXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgcmVxdWVzdCA9IHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgcmVzcG9uc2UgPSByZXN1bHQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25SZXF1ZXN0OiBtdXN0IHJldHVybiBuZXcgUmVxdWVzdCgpIG9yIFJlc3BvbnNlKCkgd2hlbiBtb2RpZnlpbmcgdGhlIHJlcXVlc3RcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghcmVzcG9uc2UpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gocmVxdWVzdCwgcmVxdWVzdEluaXRFeHQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICAgIGxldCBlcnJvckFmdGVyTWlkZGxld2FyZSA9IGVycm9yMjtcbiAgICAgICAgaWYgKG1pZGRsZXdhcmVzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSBtaWRkbGV3YXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgbSA9IG1pZGRsZXdhcmVzW2ldO1xuICAgICAgICAgICAgaWYgKG0gJiYgdHlwZW9mIG0gPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG0ub25FcnJvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25FcnJvcih7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3JBZnRlck1pZGRsZXdhcmUsXG4gICAgICAgICAgICAgICAgc2NoZW1hUGF0aCxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgZXJyb3JBZnRlck1pZGRsZXdhcmUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yQWZ0ZXJNaWRkbGV3YXJlID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uRXJyb3I6IG11c3QgcmV0dXJuIG5ldyBSZXNwb25zZSgpIG9yIGluc3RhbmNlIG9mIEVycm9yXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvckFmdGVyTWlkZGxld2FyZSkge1xuICAgICAgICAgIHRocm93IGVycm9yQWZ0ZXJNaWRkbGV3YXJlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWlkZGxld2FyZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBtaWRkbGV3YXJlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGNvbnN0IG0gPSBtaWRkbGV3YXJlc1tpXTtcbiAgICAgICAgICBpZiAobSAmJiB0eXBlb2YgbSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgbS5vblJlc3BvbnNlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG0ub25SZXNwb25zZSh7XG4gICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICBzY2hlbWFQYXRoLFxuICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgaWYgKCEocmVzdWx0IGluc3RhbmNlb2YgUmVzcG9uc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib25SZXNwb25zZTogbXVzdCByZXR1cm4gbmV3IFJlc3BvbnNlKCkgd2hlbiBtb2RpZnlpbmcgdGhlIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3BvbnNlID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDQgfHwgcmVxdWVzdC5tZXRob2QgPT09IFwiSEVBRFwiIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwiQ29udGVudC1MZW5ndGhcIikgPT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2Uub2sgPyB7IGRhdGE6IHZvaWQgMCwgcmVzcG9uc2UgfSA6IHsgZXJyb3I6IHZvaWQgMCwgcmVzcG9uc2UgfTtcbiAgICB9XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICBpZiAocGFyc2VBcyA9PT0gXCJzdHJlYW1cIikge1xuICAgICAgICByZXR1cm4geyBkYXRhOiByZXNwb25zZS5ib2R5LCByZXNwb25zZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZGF0YTogYXdhaXQgcmVzcG9uc2VbcGFyc2VBc10oKSwgcmVzcG9uc2UgfTtcbiAgICB9XG4gICAgbGV0IGVycm9yID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgIHRyeSB7XG4gICAgICBlcnJvciA9IEpTT04ucGFyc2UoZXJyb3IpO1xuICAgIH0gY2F0Y2gge1xuICAgIH1cbiAgICByZXR1cm4geyBlcnJvciwgcmVzcG9uc2UgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlcXVlc3QobWV0aG9kLCB1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogbWV0aG9kLnRvVXBwZXJDYXNlKCkgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIEdFVCBlbmRwb2ludCAqL1xuICAgIEdFVCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJHRVRcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgUFVUIGVuZHBvaW50ICovXG4gICAgUFVUKHVybCwgaW5pdCkge1xuICAgICAgcmV0dXJuIGNvcmVGZXRjaCh1cmwsIHsgLi4uaW5pdCwgbWV0aG9kOiBcIlBVVFwiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBQT1NUIGVuZHBvaW50ICovXG4gICAgUE9TVCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJQT1NUXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIERFTEVURSBlbmRwb2ludCAqL1xuICAgIERFTEVURSh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJERUxFVEVcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgT1BUSU9OUyBlbmRwb2ludCAqL1xuICAgIE9QVElPTlModXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiT1BUSU9OU1wiIH0pO1xuICAgIH0sXG4gICAgLyoqIENhbGwgYSBIRUFEIGVuZHBvaW50ICovXG4gICAgSEVBRCh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJIRUFEXCIgfSk7XG4gICAgfSxcbiAgICAvKiogQ2FsbCBhIFBBVENIIGVuZHBvaW50ICovXG4gICAgUEFUQ0godXJsLCBpbml0KSB7XG4gICAgICByZXR1cm4gY29yZUZldGNoKHVybCwgeyAuLi5pbml0LCBtZXRob2Q6IFwiUEFUQ0hcIiB9KTtcbiAgICB9LFxuICAgIC8qKiBDYWxsIGEgVFJBQ0UgZW5kcG9pbnQgKi9cbiAgICBUUkFDRSh1cmwsIGluaXQpIHtcbiAgICAgIHJldHVybiBjb3JlRmV0Y2godXJsLCB7IC4uLmluaXQsIG1ldGhvZDogXCJUUkFDRVwiIH0pO1xuICAgIH0sXG4gICAgLyoqIFJlZ2lzdGVyIG1pZGRsZXdhcmUgKi9cbiAgICB1c2UoLi4ubWlkZGxld2FyZSkge1xuICAgICAgZm9yIChjb25zdCBtIG9mIG1pZGRsZXdhcmUpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtICE9PSBcIm9iamVjdFwiIHx8ICEoXCJvblJlcXVlc3RcIiBpbiBtIHx8IFwib25SZXNwb25zZVwiIGluIG0gfHwgXCJvbkVycm9yXCIgaW4gbSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIG11c3QgYmUgYW4gb2JqZWN0IHdpdGggb25lIG9mIGBvblJlcXVlc3QoKWAsIGBvblJlc3BvbnNlKCkgb3IgYG9uRXJyb3IoKWBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbWlkZGxld2FyZXMucHVzaChtKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKiBVbnJlZ2lzdGVyIG1pZGRsZXdhcmUgKi9cbiAgICBlamVjdCguLi5taWRkbGV3YXJlKSB7XG4gICAgICBmb3IgKGNvbnN0IG0gb2YgbWlkZGxld2FyZSkge1xuICAgICAgICBjb25zdCBpID0gbWlkZGxld2FyZXMuaW5kZXhPZihtKTtcbiAgICAgICAgaWYgKGkgIT09IC0xKSB7XG4gICAgICAgICAgbWlkZGxld2FyZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuY2xhc3MgUGF0aENhbGxGb3J3YXJkZXIge1xuICBjb25zdHJ1Y3RvcihjbGllbnQsIHVybCkge1xuICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMudXJsID0gdXJsO1xuICB9XG4gIEdFVCA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LkdFVCh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIFBVVCA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LlBVVCh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIFBPU1QgPSAoaW5pdCkgPT4ge1xuICAgIHJldHVybiB0aGlzLmNsaWVudC5QT1NUKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgREVMRVRFID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuREVMRVRFKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbiAgT1BUSU9OUyA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50Lk9QVElPTlModGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBIRUFEID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuSEVBRCh0aGlzLnVybCwgaW5pdCk7XG4gIH07XG4gIFBBVENIID0gKGluaXQpID0+IHtcbiAgICByZXR1cm4gdGhpcy5jbGllbnQuUEFUQ0godGhpcy51cmwsIGluaXQpO1xuICB9O1xuICBUUkFDRSA9IChpbml0KSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50LlRSQUNFKHRoaXMudXJsLCBpbml0KTtcbiAgfTtcbn1cbmNsYXNzIFBhdGhDbGllbnRQcm94eUhhbmRsZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmNsaWVudCA9IG51bGw7XG4gIH1cbiAgLy8gQXNzdW1lIHRoZSBwcm9wZXJ0eSBpcyBhbiBVUkwuXG4gIGdldChjb3JlQ2xpZW50LCB1cmwpIHtcbiAgICBjb25zdCBmb3J3YXJkZXIgPSBuZXcgUGF0aENhbGxGb3J3YXJkZXIoY29yZUNsaWVudCwgdXJsKTtcbiAgICB0aGlzLmNsaWVudFt1cmxdID0gZm9yd2FyZGVyO1xuICAgIHJldHVybiBmb3J3YXJkZXI7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyYXBBc1BhdGhCYXNlZENsaWVudChjb3JlQ2xpZW50KSB7XG4gIGNvbnN0IGhhbmRsZXIgPSBuZXcgUGF0aENsaWVudFByb3h5SGFuZGxlcigpO1xuICBjb25zdCBwcm94eSA9IG5ldyBQcm94eShjb3JlQ2xpZW50LCBoYW5kbGVyKTtcbiAgZnVuY3Rpb24gQ2xpZW50KCkge1xuICB9XG4gIENsaWVudC5wcm90b3R5cGUgPSBwcm94eTtcbiAgY29uc3QgY2xpZW50ID0gbmV3IENsaWVudCgpO1xuICBoYW5kbGVyLmNsaWVudCA9IGNsaWVudDtcbiAgcmV0dXJuIGNsaWVudDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhdGhCYXNlZENsaWVudChjbGllbnRPcHRpb25zKSB7XG4gIHJldHVybiB3cmFwQXNQYXRoQmFzZWRDbGllbnQoY3JlYXRlQ2xpZW50KGNsaWVudE9wdGlvbnMpKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmICh2YWx1ZSA9PT0gdm9pZCAwIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiRGVlcGx5LW5lc3RlZCBhcnJheXMvb2JqZWN0cyBhcmVuXFx1MjAxOXQgc3VwcG9ydGVkLiBQcm92aWRlIHlvdXIgb3duIGBxdWVyeVNlcmlhbGl6ZXIoKWAgdG8gaGFuZGxlIHRoZXNlLlwiXG4gICAgKTtcbiAgfVxuICByZXR1cm4gYCR7bmFtZX09JHtvcHRpb25zPy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWUgOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWA7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3RQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IHZhbHVlcyA9IFtdO1xuICBjb25zdCBqb2luZXIgPSB7XG4gICAgc2ltcGxlOiBcIixcIixcbiAgICBsYWJlbDogXCIuXCIsXG4gICAgbWF0cml4OiBcIjtcIlxuICB9W29wdGlvbnMuc3R5bGVdIHx8IFwiJlwiO1xuICBpZiAob3B0aW9ucy5zdHlsZSAhPT0gXCJkZWVwT2JqZWN0XCIgJiYgb3B0aW9ucy5leHBsb2RlID09PSBmYWxzZSkge1xuICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgdmFsdWVzLnB1c2goaywgb3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWVba10gOiBlbmNvZGVVUklDb21wb25lbnQodmFsdWVba10pKTtcbiAgICB9XG4gICAgY29uc3QgZmluYWwyID0gdmFsdWVzLmpvaW4oXCIsXCIpO1xuICAgIHN3aXRjaCAob3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2FzZSBcImZvcm1cIjoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbDJ9YDtcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJsYWJlbFwiOiB7XG4gICAgICAgIHJldHVybiBgLiR7ZmluYWwyfWA7XG4gICAgICB9XG4gICAgICBjYXNlIFwibWF0cml4XCI6IHtcbiAgICAgICAgcmV0dXJuIGA7JHtuYW1lfT0ke2ZpbmFsMn1gO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gZmluYWwyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICBjb25zdCBmaW5hbE5hbWUgPSBvcHRpb25zLnN0eWxlID09PSBcImRlZXBPYmplY3RcIiA/IGAke25hbWV9WyR7a31dYCA6IGs7XG4gICAgdmFsdWVzLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0oZmluYWxOYW1lLCB2YWx1ZVtrXSwgb3B0aW9ucykpO1xuICB9XG4gIGNvbnN0IGZpbmFsID0gdmFsdWVzLmpvaW4oam9pbmVyKTtcbiAgcmV0dXJuIG9wdGlvbnMuc3R5bGUgPT09IFwibGFiZWxcIiB8fCBvcHRpb25zLnN0eWxlID09PSBcIm1hdHJpeFwiID8gYCR7am9pbmVyfSR7ZmluYWx9YCA6IGZpbmFsO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplQXJyYXlQYXJhbShuYW1lLCB2YWx1ZSwgb3B0aW9ucykge1xuICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cbiAgaWYgKG9wdGlvbnMuZXhwbG9kZSA9PT0gZmFsc2UpIHtcbiAgICBjb25zdCBqb2luZXIyID0geyBmb3JtOiBcIixcIiwgc3BhY2VEZWxpbWl0ZWQ6IFwiJTIwXCIsIHBpcGVEZWxpbWl0ZWQ6IFwifFwiIH1bb3B0aW9ucy5zdHlsZV0gfHwgXCIsXCI7XG4gICAgY29uc3QgZmluYWwgPSAob3B0aW9ucy5hbGxvd1Jlc2VydmVkID09PSB0cnVlID8gdmFsdWUgOiB2YWx1ZS5tYXAoKHYpID0+IGVuY29kZVVSSUNvbXBvbmVudCh2KSkpLmpvaW4oam9pbmVyMik7XG4gICAgc3dpdGNoIChvcHRpb25zLnN0eWxlKSB7XG4gICAgICBjYXNlIFwic2ltcGxlXCI6IHtcbiAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgICAgfVxuICAgICAgY2FzZSBcImxhYmVsXCI6IHtcbiAgICAgICAgcmV0dXJuIGAuJHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgY2FzZSBcIm1hdHJpeFwiOiB7XG4gICAgICAgIHJldHVybiBgOyR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgICAgLy8gY2FzZSBcInNwYWNlRGVsaW1pdGVkXCI6XG4gICAgICAvLyBjYXNlIFwicGlwZURlbGltaXRlZFwiOlxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gYCR7bmFtZX09JHtmaW5hbH1gO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBqb2luZXIgPSB7IHNpbXBsZTogXCIsXCIsIGxhYmVsOiBcIi5cIiwgbWF0cml4OiBcIjtcIiB9W29wdGlvbnMuc3R5bGVdIHx8IFwiJlwiO1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUgPT09IFwic2ltcGxlXCIgfHwgb3B0aW9ucy5zdHlsZSA9PT0gXCJsYWJlbFwiKSB7XG4gICAgICB2YWx1ZXMucHVzaChvcHRpb25zLmFsbG93UmVzZXJ2ZWQgPT09IHRydWUgPyB2IDogZW5jb2RlVVJJQ29tcG9uZW50KHYpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdiwgb3B0aW9ucykpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3B0aW9ucy5zdHlsZSA9PT0gXCJsYWJlbFwiIHx8IG9wdGlvbnMuc3R5bGUgPT09IFwibWF0cml4XCIgPyBgJHtqb2luZXJ9JHt2YWx1ZXMuam9pbihqb2luZXIpfWAgOiB2YWx1ZXMuam9pbihqb2luZXIpO1xufVxuZnVuY3Rpb24gY3JlYXRlUXVlcnlTZXJpYWxpemVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHF1ZXJ5U2VyaWFsaXplcihxdWVyeVBhcmFtcykge1xuICAgIGNvbnN0IHNlYXJjaCA9IFtdO1xuICAgIGlmIChxdWVyeVBhcmFtcyAmJiB0eXBlb2YgcXVlcnlQYXJhbXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBxdWVyeVBhcmFtcykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5UGFyYW1zW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZUFycmF5UGFyYW0obmFtZSwgdmFsdWUsIHtcbiAgICAgICAgICAgICAgc3R5bGU6IFwiZm9ybVwiLFxuICAgICAgICAgICAgICBleHBsb2RlOiB0cnVlLFxuICAgICAgICAgICAgICAuLi5vcHRpb25zPy5hcnJheSxcbiAgICAgICAgICAgICAgYWxsb3dSZXNlcnZlZDogb3B0aW9ucz8uYWxsb3dSZXNlcnZlZCB8fCBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBzZWFyY2gucHVzaChcbiAgICAgICAgICAgIHNlcmlhbGl6ZU9iamVjdFBhcmFtKG5hbWUsIHZhbHVlLCB7XG4gICAgICAgICAgICAgIHN0eWxlOiBcImRlZXBPYmplY3RcIixcbiAgICAgICAgICAgICAgZXhwbG9kZTogdHJ1ZSxcbiAgICAgICAgICAgICAgLi4ub3B0aW9ucz8ub2JqZWN0LFxuICAgICAgICAgICAgICBhbGxvd1Jlc2VydmVkOiBvcHRpb25zPy5hbGxvd1Jlc2VydmVkIHx8IGZhbHNlXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VhcmNoLnB1c2goc2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUsIG9wdGlvbnMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlYXJjaC5qb2luKFwiJlwiKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRQYXRoU2VyaWFsaXplcihwYXRobmFtZSwgcGF0aFBhcmFtcykge1xuICBsZXQgbmV4dFVSTCA9IHBhdGhuYW1lO1xuICBmb3IgKGNvbnN0IG1hdGNoIG9mIHBhdGhuYW1lLm1hdGNoKFBBVEhfUEFSQU1fUkUpID8/IFtdKSB7XG4gICAgbGV0IG5hbWUgPSBtYXRjaC5zdWJzdHJpbmcoMSwgbWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgbGV0IGV4cGxvZGUgPSBmYWxzZTtcbiAgICBsZXQgc3R5bGUgPSBcInNpbXBsZVwiO1xuICAgIGlmIChuYW1lLmVuZHNXaXRoKFwiKlwiKSkge1xuICAgICAgZXhwbG9kZSA9IHRydWU7XG4gICAgICBuYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5sZW5ndGggLSAxKTtcbiAgICB9XG4gICAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIi5cIikpIHtcbiAgICAgIHN0eWxlID0gXCJsYWJlbFwiO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH0gZWxzZSBpZiAobmFtZS5zdGFydHNXaXRoKFwiO1wiKSkge1xuICAgICAgc3R5bGUgPSBcIm1hdHJpeFwiO1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgIH1cbiAgICBpZiAoIXBhdGhQYXJhbXMgfHwgcGF0aFBhcmFtc1tuYW1lXSA9PT0gdm9pZCAwIHx8IHBhdGhQYXJhbXNbbmFtZV0gPT09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHBhdGhQYXJhbXNbbmFtZV07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzZXJpYWxpemVBcnJheVBhcmFtKG5hbWUsIHZhbHVlLCB7IHN0eWxlLCBleHBsb2RlIH0pKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBzZXJpYWxpemVPYmplY3RQYXJhbShuYW1lLCB2YWx1ZSwgeyBzdHlsZSwgZXhwbG9kZSB9KSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHN0eWxlID09PSBcIm1hdHJpeFwiKSB7XG4gICAgICBuZXh0VVJMID0gbmV4dFVSTC5yZXBsYWNlKG1hdGNoLCBgOyR7c2VyaWFsaXplUHJpbWl0aXZlUGFyYW0obmFtZSwgdmFsdWUpfWApO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIG5leHRVUkwgPSBuZXh0VVJMLnJlcGxhY2UobWF0Y2gsIHN0eWxlID09PSBcImxhYmVsXCIgPyBgLiR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gIDogZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG4gIH1cbiAgcmV0dXJuIG5leHRVUkw7XG59XG5mdW5jdGlvbiBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIoYm9keSwgaGVhZGVycykge1xuICBpZiAoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKSB7XG4gICAgcmV0dXJuIGJvZHk7XG4gIH1cbiAgaWYgKGhlYWRlcnMpIHtcbiAgICBjb25zdCBjb250ZW50VHlwZSA9IGhlYWRlcnMuZ2V0IGluc3RhbmNlb2YgRnVuY3Rpb24gPyBoZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSA/PyBoZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSA6IGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPz8gaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICBpZiAoY29udGVudFR5cGUgPT09IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpIHtcbiAgICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zKGJvZHkpLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShib2R5KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpbmFsVVJMKHBhdGhuYW1lLCBvcHRpb25zKSB7XG4gIGxldCBmaW5hbFVSTCA9IGAke29wdGlvbnMuYmFzZVVybH0ke3BhdGhuYW1lfWA7XG4gIGlmIChvcHRpb25zLnBhcmFtcz8ucGF0aCkge1xuICAgIGZpbmFsVVJMID0gZGVmYXVsdFBhdGhTZXJpYWxpemVyKGZpbmFsVVJMLCBvcHRpb25zLnBhcmFtcy5wYXRoKTtcbiAgfVxuICBsZXQgc2VhcmNoID0gb3B0aW9ucy5xdWVyeVNlcmlhbGl6ZXIob3B0aW9ucy5wYXJhbXMucXVlcnkgPz8ge30pO1xuICBpZiAoc2VhcmNoLnN0YXJ0c1dpdGgoXCI/XCIpKSB7XG4gICAgc2VhcmNoID0gc2VhcmNoLnN1YnN0cmluZygxKTtcbiAgfVxuICBpZiAoc2VhcmNoKSB7XG4gICAgZmluYWxVUkwgKz0gYD8ke3NlYXJjaH1gO1xuICB9XG4gIHJldHVybiBmaW5hbFVSTDtcbn1cbmZ1bmN0aW9uIG1lcmdlSGVhZGVycyguLi5hbGxIZWFkZXJzKSB7XG4gIGNvbnN0IGZpbmFsSGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGZvciAoY29uc3QgaCBvZiBhbGxIZWFkZXJzKSB7XG4gICAgaWYgKCFoIHx8IHR5cGVvZiBoICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaXRlcmF0b3IgPSBoIGluc3RhbmNlb2YgSGVhZGVycyA/IGguZW50cmllcygpIDogT2JqZWN0LmVudHJpZXMoaCk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgaXRlcmF0b3IpIHtcbiAgICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5kZWxldGUoayk7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgZm9yIChjb25zdCB2MiBvZiB2KSB7XG4gICAgICAgICAgZmluYWxIZWFkZXJzLmFwcGVuZChrLCB2Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIGZpbmFsSGVhZGVycy5zZXQoaywgdik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmaW5hbEhlYWRlcnM7XG59XG5mdW5jdGlvbiByZW1vdmVUcmFpbGluZ1NsYXNoKHVybCkge1xuICBpZiAodXJsLmVuZHNXaXRoKFwiL1wiKSkge1xuICAgIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5leHBvcnQgeyBjcmVhdGVGaW5hbFVSTCwgY3JlYXRlUGF0aEJhc2VkQ2xpZW50LCBjcmVhdGVRdWVyeVNlcmlhbGl6ZXIsIGNyZWF0ZUNsaWVudCBhcyBkZWZhdWx0LCBkZWZhdWx0Qm9keVNlcmlhbGl6ZXIsIGRlZmF1bHRQYXRoU2VyaWFsaXplciwgbWVyZ2VIZWFkZXJzLCByYW5kb21JRCwgcmVtb3ZlVHJhaWxpbmdTbGFzaCwgc2VyaWFsaXplQXJyYXlQYXJhbSwgc2VyaWFsaXplT2JqZWN0UGFyYW0sIHNlcmlhbGl6ZVByaW1pdGl2ZVBhcmFtLCB3cmFwQXNQYXRoQmFzZWRDbGllbnQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/openapi-fetch@0.14.1/node_modules/openapi-fetch/dist/index.mjs\n");

/***/ })

};
;